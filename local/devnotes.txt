Implementation of new argument passing and to-do list
-----------------------------------------------------

s simplify, v by value, r by reference, b bare reference
only v has the full vector-like features

News flash. I think there is no point having both r and b. At the moment, the
only thing r adds to b is bounds checking, but there doesn't seem to be much
point in that for luajr. One could imagine r as a version of v which doesn't
make a copy when it is initialized, only when it is modified, but I think
there's not much point in that either, as we would have to add checks to e.g.
__newindex and any vector modifying methods; meanwhile, if you want to return
something by value, it needs to get copied anyway; if it is going to be different
in size etc from the passed in value

to e.g.

(1) b - bare reference

logical/real/integer/character vector
implement in metatable:
 __len (vector length) (obj)
 __index (gettable) (obj, key)
 __newindex (settable) (obj, key, value)

todo
[x] get integration of luajr.lua in
[x] verify speed of implementation
[x] get implementation working
[ ] full testing

(2) s - simplify
[x] basic 's'
[x] 1, 2, 3, etc
[x] full testing
[ ] special behaviour for NA (see test-lua_func.R)

(3) r - by reference

as b, but with bounds checking
[x] done
[ ] full testing

(4) v - by value

FOR RESIZING:
see https://github.com/r-lib/cpp11/blob/51f4cd5ad9425a491dedf951a3679346d416e51c/inst/include/cpp11/list.hpp#L116C1-L117C75

  data_ = data_ == R_NilValue ? safe[Rf_allocVector](VECSXP, new_capacity)
                              : safe[Rf_xlengthgets](data_, new_capacity);

(data_ is just the SEXP)

see builtin.c, xlengthgets

PLAIN VECTORS
ASSIGNMENT ETC
    v = v1
    v:assign(v1)        -- copy v1 to v (what if v1 is different type?) v1 can be rvalue, table, etc
    v:assign(n, val)    -- make v hold n copies of val (what if val is different type?)
    v.type              -- ???

ACCESS ETC
    #v                  -- length of vector
    v[i]                -- get ith element (i integer)
    v[i] = x            -- set ith element (i integer)
    v:data()            -- gives ptr to data
    pairs(v), ipairs(v) -- iterates through

CAPACITY (version 2)
    v:reserve()
    v:capacity()
    v:shrink_to_fit()   -- ???

MODIFY (version 2)
    v:clear()
    v:resize(n)
    v:resize(n, val)
    v:push_back(val)
    v:pop_back()
    v:insert(i, n, val)
    v:insert(i, v1)
    v:erase(i)
    v:erase(i, end)

R-SPECIFIC (version 2)
    v("attr:z")         -- get attribute z
    v("attr:z", x)      -- set attribute z
    v("names")          -- get names
    v("names", i)       -- get name of ith element
    v("names", ol, nw)  -- change names (like data.table)
    v("class")          -- get class
    v("class", cl)      -- set class
    v("order", ord)     -- reorder elements (like data.table)


LISTS
The idea here is to have all (or most) the functionality of the vectors but
without using any named members; can use __len (#), __unm (-), __call (()),
__pairs, __ipairs. So here showing functionality of vectors (column 1) and
equivalents in lists (column 2)

ASSIGNMENT ETC
    v:assign(v1)        v = v1
 -- v:assign(n, val)    not listy
 -- v.type              not listy

ACCESS ETC
    #v                  #v
    v[i]                v[i] or v[k]
    v[i] = x            v[i] = x or v[k] = x
 -- v:data()            not listy
    pairs(v), ipairs(v) iterates through


CAPACITY (version 2)
 -- v:reserve()         not listy
 -- v:capacity()        not listy
 -- v:shrink_to_fit()   not listy

MODIFY (version 2)
    v:clear()           v = luajr.list()
 -- v:resize(n)         not listy
 -- v:resize(n, val)    not listy
 -- v:insert(i, n, val) not listy
    v:insert(i, v1)     concat operator <<-
    v:erase(i)          v[i] = nil or v[k] = nil
    v:erase(i, end)     v[i] = nil; v[i+1] = nil; ... or v[k1] = nil; v[k2] = nil; ...
    v:push_back(val)    v[#v + 1] = val
    v:pop_back()        v[#v] = nil

R-SPECIFIC (version 2)
    v("attr:z")         -- get attribute z
    v("attr:z", x)      -- set attribute z
    v("names")          -- get names
    v("names", i)       -- get name i
    v("names", ol, nw)  -- change names (like data.table)
    v("class")          -- get class
    v("class", cl)      -- set class
    v("order", ord)     -- reorder elements (like data.table)
 -- v("nrow")           ?? number of rows (data.frame only)
 -- v("nrow", nr)       ?? set number of rows (data.frame only)

(4) v - by value

(5) c - checked bare reference (if needed?)


Better R argument passing
-------------------------

I think I need to overhaul the current system of args codes s, a, and t,
for pass by reference and other improvements. I think these are the things to
think about:
 scalars and small tuples
   I think the solution here is these should be passed by value and imported
   as normal Lua objects (nil if length = 0, atomic if length = 1, table if
   length > 1). Perhaps args codes 1,2,3 etc can be used to force length? Yes
   so this should definitely be an option, questions are (1) what to call it,
   (2) what to do when a list or a xptr is passed in. I think 1,2,3 should work
   for logical/int/real, 1 should also work for null/xptr, numbers should not
   work for list, and list -> s means apply s to everything within list. Then
   s simplify, v by value, r by reference, u for unchecked bare reference,
   c for checked bare reference (?) (i.e. for testing that bare reference would
   be safe.)
 number/logical vectors (logical, int, real)
   I think what we want to do here is insist that these are arrays and have
   them pass by reference. With a fully kitted out metatable, it would be
   possible to allow vector ops (+, *, etc), but that can be saved for later.
   I think strip vector names, too (or require workarounds to use them).
   But then what if we really want them to be scalars -- x[0] is cumbersome
   and requires length checks within lua.  not sure. Also, what if we want to
   resize a vector? Do we have bounds checks? I think there need to be two
   kinds of vector essentially, a bare kind which is just cdata and a protected
   kind which would have bounds checking, know its length, allow resizing, etc.
 character vectors
   have to be handled carefully so that reassigning their elements doesn't
   crash R.
 data.frame
   would be great to be able to pass in by reference similar to current
   R.DataFrame structure (i.e. elements have the names of the columns).
   on the other hand, this doesn't preserve order of columns; is that
   important? could have as extra info an array based mechanism i.e. so that
   df.x and df.y can be used as well as df[0] and df[1]. This would use
   a metatable approach. __newindex could be used to add new columns I guess.
   this wouldn't need a metatable approach actually, the table would just have
   both integer and string keys pointing to the same data.
 lists
   similar to data.frame I guess; need to handle names gracefully. Which I
   think requires an overload of __index in the metatable. (and __newindex?)
 matrix/array with multiple dimensions
   probaby the easiest way of allowing access to matrices is e.g. x[row][col].
Note that params to a function can be inspected; see
https://stackoverflow.com/questions/3097209/lua-get-the-list-of-parameter-names-of-a-function-from-outside-the-function
This would allow me to do positional argument passing -- basically if any
parameters are named, kick in to positional arguments.

Whatever solution is chosen, need to make sure that Lua not remembering the
order of named elements doesn't bite, or put back the warning in push_R_vector
about Lua not remembering the order. I think the multiple definition of 0/1
versus named elements will be key here.


luajit as subfolder in src/luajit
---------------------------------

I did this by using git subtree, explained here:

https://blog.developer.atlassian.com/the-power-of-git-subtree/

In particular, I added git aliases sba and sbu to ~/.gitconfig:

[alias]
    # the acronym stands for "subtree add"
    sba = "!f() { git subtree add --prefix $2 $1 ${3-master} --squash; }; f"
    # the acronym stands for "subtree update"
    sbu = "!f() { git subtree pull --prefix $2 $1 ${3-master} --squash; }; f"

(note that I added a configurable branch as arg 3)

then from the top-level luajr directory, added luajit as a subdirectory of src as follows:

git sba https://github.com/LuaJIT/LuaJIT.git src/luajit v2.1

to update the subdirectory (i.e. pull any updates to luajit), use:

git sbu https://github.com/LuaJIT/LuaJIT.git src/luajit v2.1


Warnings when making luajit
---------------------------

Having -march=native in CFLAGS causes a warning about an uninitialized fs.len
to be emitted when compiling ljamalg.o. Having looked at the offending source,
it's not a real issue.
