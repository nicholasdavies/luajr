# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Create a new Lua state.
#'
#' Creates a new, empty Lua state and returns an external pointer wrapping that
#' state.
#'
#' All Lua code is executed within a given Lua state. A Lua state is similar to
#' the global environment in R, in that it is where all variables and functions
#' are defined. \pkg{luajr} automatically maintains a "default" Lua state, so
#' most users of \pkg{luajr} will not need to use \code{\link{lua_open}}.
#'
#' However, if for whatever reason you want to maintain multiple different Lua
#' states at a time, each with their own independent global variables and
#' functions, \code{\link{lua_open}} can be used to create a new Lua state
#' which can then be passed to \code{\link{lua}}, \code{\link{lua_func}} and
#' \code{\link{lua_shell}} via the \code{L} parameter. These functions will
#' then operate within that Lua state instead of the default one. The default
#' Lua state can be specified explicitly with \code{L = NULL}.
#'
#' Note that there is currently no way (provided by \pkg{luajr}) of saving a
#' Lua state to disk so that the state can be restarted later. Also, there is
#' no \code{lua_close} in \pkg{luajr} because when the R object returned by
#' \code{\link{lua_open}} is garbage collected, the Lua state is closed then.
#'
#' @return External pointer wrapping the Lua state.
#' @examples
#' L1 = lua_open()
#' lua("a = 2")
#' lua("a = 4", L = L1)
#' lua("print(a)")
#' lua("print(a)", L = L1)
#' @export lua_open
lua_open <- function() {
    .Call(`_luajr_luajr_open`)
}

luajr_run <- function(code, mode, Lxp) {
    .Call(`_luajr_luajr_run`, code, mode, Lxp)
}

luajr_func_create <- function(code, Lxp) {
    .Call(`_luajr_luajr_func_create`, code, Lxp)
}

luajr_func_call <- function(fptr, alist, acode, Lxp) {
    .Call(`_luajr_luajr_func_call`, fptr, alist, acode, Lxp)
}

